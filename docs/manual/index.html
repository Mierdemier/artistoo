<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | cpmjs</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<script>
MathJax = {
	tex: {
		inlineMath: [['$', '$']]
	}
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ingewortel/cpmjs"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/introCPM.html"><a href="manual/introCPM.html" data-ice="link">An introduction to the CPM</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/introCPM.html"><a href="manual/introCPM.html#a-brief-history-of-the-cpm" data-ice="link">A brief history of the CPM</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/introCPM.html"><a href="manual/introCPM.html#cpm--basic-principle" data-ice="link">CPM: basic principle</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#a-note-on-terminology" data-ice="link">A note on terminology</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#simulation-algorithm" data-ice="link">Simulation algorithm</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/introCPM.html"><a href="manual/introCPM.html#the-hamiltonian" data-ice="link">The Hamiltonian</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#adhesion" data-ice="link">Adhesion</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#volume" data-ice="link">Volume</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#perimeter" data-ice="link">Perimeter</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#cell-motion--extrinsic" data-ice="link">Cell motion: extrinsic</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#cell-motion--intrinsic" data-ice="link">Cell motion: intrinsic</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/introCPM.html"><a href="manual/introCPM.html#enforcing-cell-connectivity" data-ice="link">Enforcing cell connectivity</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/introCPM.html"><a href="manual/introCPM.html#references" data-ice="link">References</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/installation.html"><a href="manual/installation.html" data-ice="link">Getting started</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#set-up-cpmjs-in-3-easy-steps" data-ice="link">Set up CPMjs in 3 easy steps</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#step-1--download-the-repository-" data-ice="link">Step 1: download the repository.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#step-2--install-node-dependencies-" data-ice="link">Step 2: install node dependencies.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#step-3--link-the-build-in-your-code-" data-ice="link">Step 3: link the build in your code.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#additional-notes" data-ice="link">Additional notes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/quickstart.html"><a href="manual/quickstart.html" data-ice="link">Your First Simulation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/quickstart.html"><a href="manual/quickstart.html#set-up-a-simulation-in-the-web-browser" data-ice="link">Set up a simulation in the web browser</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#an-html-template-page" data-ice="link">An HTML template page</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/quickstart.html"><a href="manual/quickstart.html#set-up-a-simulation-in-nodejs" data-ice="link">Set up a simulation in nodejs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/quickstart.html"><a href="manual/quickstart.html#writing-your-simulation" data-ice="link">Writing your simulation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#step-1---configure-the-cpm--amp--simulation" data-ice="link">Step 1 : Configure the CPM &amp; Simulation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#step-2--create-a-simulation-object" data-ice="link">Step 2: Create a simulation object</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-nodejs" data-ice="link">In nodejs</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-html" data-ice="link">In HTML</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#step-3---tell-the-simulation-to-run" data-ice="link">Step 3 : Tell the simulation to run</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-nodejs" data-ice="link">In nodejs</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-html" data-ice="link">In HTML</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html" data-ice="link">An HTML template page</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#an-html-template" data-ice="link">An HTML template</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-1---create-a-basic-html-page" data-ice="link">Step 1 : Create a basic HTML page</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-2---configure-the-header" data-ice="link">Step 2 : Configure the header</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-3---add-javascript" data-ice="link">Step 3 : Add JavaScript</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-4--write-the-body" data-ice="link">Step 4: Write the body</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-5--optional---add-css" data-ice="link">Step 5 (optional): Add CSS</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html" data-ice="link">Configuring Simulations (1)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#configuring-the-cpm-itself" data-ice="link">Configuring the CPM itself</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#changing-cpm-constraints" data-ice="link">Changing CPM constraints</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#configuring-the-grid" data-ice="link">Configuring the grid</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#-strong-field-size--strong-" data-ice="link">Field size</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#-strong-grid-boundaries--strong-" data-ice="link">Grid boundaries</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#setting-a-seed" data-ice="link">Setting a seed</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#configuring-the-simulation-object" data-ice="link">Configuring the Simulation object</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#controlling-the-simulation" data-ice="link">Controlling the simulation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#controlling-the-visualization" data-ice="link">Controlling the visualization</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#controlling-outputs" data-ice="link">Controlling outputs</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><h1 id="cpmjs">CPMjs</h1>
<p>This manual is under construction. It currently contains some basic instructions
on how to get started, but stay tuned for the most recent version! In
the meantime, see the <a href>examples</a>
(with provided <a href="https://github.com/ingewortel/cpmjs/tree/master/examples">code</a>)
and the full <a href="https://ingewortel.github.io/cpmjs.github.io/identifiers.html">method documentation</a>
to get an idea of what you can do with CPMjs.
</p>
<h2 id="why-cpmjs-">Why CPMjs?</h2>
<p>CPMjs implements Cellular Potts Models in JavaScript. Yep, you read it correctly:
JavaScript.
</p>

<p>This somewhat unorthodox choice allowed us to harness some key strengths of web
programming to provide the following features:
</p>
<ul>
<li>Build models in the form of interactive and explorable web
applications that:<ul>
<li>you can easily share with other users without any fuss:
your audience needs no special software except a common web browser;</li>
<li>are just as fast as simulations in traditional modelling
frameworks!</li>
</ul>
</li>
<li>Unlocking CPM models for new users:<ul>
<li>biologists can access &amp; modify CPMjs models created by others
(collaborators, in publications) - without needing to program
anything themselves;</li>
<li>a large existing community of web programmers will be able to contribute
to the framework.</li>
</ul>
</li>
</ul>
<h3 id="build--share--explore">Build, share, explore</h3>
<p>Simulation models have traditionally been used by a small group of computational
biologists with the programming skills required to build them. While the
<em>results</em> from such models are shared with other biologists in the scientific
literature, the models themselves are typically not accessible for the target
audience.
</p>

<p>Could we change this?
</p>

<p>In the age of open science, let&apos;s make computational biology a little more
transparent. While sharing scripts and making code &quot;open-source&quot; is nice, it
still won&apos;t make simulation models accessible for a broad audience of biologists.
</p>

<p>We built CPMjs to make simulation models accessible to anyone in three steps:
</p>
<ol>
<li>You build your model in the form of an explorable web application;</li>
<li>You <strong>share</strong> this page online either on a private website (before
publication), or as supplementary material to your paper;</li>
<li>You let users <strong>explore</strong> your model by allowing them to change parameters
with something as simple as a mouse click.</li>
</ol>

<p>We believe this approach comes with some nice benefits:
</p>
<ul>
<li><strong>Reviewers</strong> can get a feel of how your model behaves. This will help them
assess the robustness and validity of results presented in a paper - speeding up
the peer review process and improving the quality of the scientific literature.</li>
<li><strong>Readers</strong> can access a simulation as supplementary material to your paper,
without needing any special software. This will help them understand your
models in more detail, and build on their conclusions with novel ideas.</li>
<li><strong>Collaborators</strong> with experimental expertise can be involved in the modelling
process earlier on, which will foster more close collaborations and improve the
exchange of ideas.</li>
<li><strong>Students</strong> can be exposed to simulation modelling early on in their program,
promoting the use of computational models by a larger audience.</li>
</ul>
<h3 id="but-what-about-speed-">But what about speed?</h3>
<p>Because simulation models tend to be computationally expensive, modelling
frameworks have traditionally been written in languages with a reputation to
be fast - such as C++ and Java. A modelling framework implemented in a
scripting language may therefore come as a surprise. But improvements in the
JavaScript engines powering common web browsers mean that performance is no
longer an issue: CPMjs lets you build simulations as web applications without
loss of speed.
</p>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>An introduction to the CPM</h1>
<p>This tutorial provides a brief introduction to the Cellular Potts Model (CPM)
framework. This intro is not specific to CPMjs, but aims to provide a general 
overview of how CPMs work and to give you a feel for what the parameters mean.
If you are already familiar with the CPM, this tutorial is probably not for you;
feel free to skip ahead to the more technical tutorials.
</p><h2>A brief history of the CPM</h2>
<p>The first version of a CPM was developed in the early nineties by 
Fran&#xE7;ois Graner and James Glazier <a href="#graner-glazier">(1)</a>. At the time,
developmental biologists had found that when two different types of embryonic 
cells were mixed, they would sort into large, homogeneous same-cell patches - 
spontaneously! Experimental studies suggested that this sorting process was 
governed by differential adhesion between the cell types.
To understand how this might work, Graner and Glazier wanted to model the
phenomenon and see if they could indeed reproduce sorting based on such
&quot;differential adhesion&quot; alone.
</p>
<p>Their model was an extension of the existing <em>Potts model</em> <a href="#basic-potts">(2)</a>, 
originally developed by physicists to simulate magnetism. The Potts model 
simulates the interaction between so-called &quot;spins&quot; on a 
crystalline lattice and looks like this:
</p>
<div>
<iframe src="./manual/asset/IsingModel.html" width="500px" height="320px"> </iframe>
</div></p><p>While the Potts model does not much look like a cell, it does have an 
interesting property: the &quot;spins&quot; on the lattice <em>automatically sort</em> into
large patches of same-spin sites. Graner and Glazier saw this, and realized 
that they could apply the same principle to the cell sorting problem - with 
some slight modifications. 
</p>
<p>A problem with the Potts model is that pixels can
only have one of two states, which could be interpreted as one cell and 
background. But Graner and Glazier needed to model multiple different cells for
their differential adhesion simulation. Their model replaced the binary &quot;spin&quot; 
property with a &quot;cell identity&quot;, a number indicating
the cell to which a grid point belonged. (The trick here is that in contrast to
the &quot;spin&quot;, the cell identity number could take on more than two 
values - allowing the co-existence of multiple cells on the same grid). 
</p>
<p>A second problem is that the patches formed in the Potts model can be of any 
size and shape, unlike cells. Graner and Glazier therefore extended the 
energy equations so that &quot;cells&quot; would roughly keep the 
same size (number of grid points) <a href="#graner-glazier">(1</a><a href="#cpm-history">,3)</a>,
and used this to model their differential adhesion hypothesis.
</p>
<p>The result was pretty magical:
<div>
<iframe src="./manual/asset/Cellsorting.html" width="500px" height="320px"> </iframe>
</div>showed how the central energy equation of the Potts model could be extended to 
incorporate processes relevant to cells, others quickly followed with their own 
variations to the cellular Potts model. In particular, Paulien Hogeweg developed 
important extensions to generalize the CPM - which is why it is also 
referred to as the Glazier-Graner-Hogeweg (GGH) model <a href="#cpm-history">(3)</a>.
</p><h2>CPM: basic principle</h2>
<p>So how does the CPM work? The basic principle is simple. We model a collection
of <em>pixels</em> on a grid, where each pixel belongs to a specific <em>cell</em>. We then
let these pixels dynamically change which cell they belong to, according to 
a set of <em>energy rules</em> that we define (which we will discuss later).
</p><h3>A note on terminology</h3>
<p>At a given point during the simulation, any single pixel always belongs to a 
single cell. We save this information in the form of integer numbers indicating 
which cell each pixel is currently part of (we call these <a href="./manual/../typedef/index.html#static-typedef-CellId">cell IDs</a> - Figure 1). Each individual cell 
on the grid thus consists of a number of pixels with the same cell ID - which is 
unique to that cell. However, some cells may be more similar to each other than 
others (for example, we may want to model a tissue of skin keratinocytes with T 
cells moving in between). We therefore also define the <em>types</em> of cells on the 
grid, but we call them by the less conventional term <a href="./manual/../typedef/index.html#static-typedef-CellKind">cell kinds</a> (Figure 1). 
This is to prevent confusion between biologists and general Potts model users, 
who classically used the word &quot;type&quot; for what we now call cell ID. We therefore 
avoid the word &quot;type&quot; whenever we can and use either cell ID or cell kind instead.
</p>


<div>
<br>
<table>
<tr>
    <td style="width:70%"> <img src="./manual/asset/cpm-explanation-01.svg" width="100%"> </td>
    <td style="width:30%"> <span style="font-size:90%"><b>Figure 1: Terminology.</b> <br>
    <i>Left: each pixel on the grid belongs either to a specific cell (as indicated
    by a positive integer number (the "cell ID"), or to the background
    (cell ID = 0). Right: The same grid as on the left, now colored by cell "kind".
    (A grid can contain different instances of the same "kind" of cell. These
    cells will have a different cell ID, but the same cell kind).
    </i></span> </td>
 </tr>
 </table>
<br>
</div>

</p><h3>Simulation algorithm</h3><p>Given a grid where all pixels have some cell ID assigned to them (possibly 0), 
we can then perform a simulation as follows (Figure 2):
</p>

<div>
<br>
<table>
<tr>
    <td style="width:70%"> <img src="./manual/asset/cpm-explanation-02.svg" width="100%"> </td>
    <td style="width:30%"> <span style="font-size:90%"><b>Figure 2: Simulation algorithm.</b> <br>
    <i>A "source" pixel (red) tries to copy its cell ID into a randomly picked
    "target" neighbor (one of the eight pixels highlighted by the dashed red line).
    If this succeeds, the target pixel gets the same cell ID as the source
    (in this case: background with cell ID = 0).
    To find the chance P<sub>copy</sub> that this will succeed, we compute
    the energy $H$ both before and after the proposed copy.
    </i></span> </td>
 </tr>
 </table>
<br>
</div>

<ol>
    <li> We choose a random pixel somewhere on the grid. We call this pixel
        the <em>source</em>. </li>
    <li> We randomly select one of its eight <em>neighbors</em> (see Figure 2).
        We call this pixel the <em>target</em>. </li>
    <li> We pretend that the source pixel would "copy" itself into the target.
        This would mean that instead of its current cell ID, the target pixel
        gets the same cell ID as the source (this may change nothing if they
        already belonged to the same cell). We compute a <em>global energy</em>
        both before and after the proposed copy attempt (we'll discuss later
        how we compute this energy, but for now, let's just assume we can do
        that somehow - Figure 2). We call that energy $H$. We then compute
        the <em>change</em> in energy that would occur if the proposed copy
        attempt were to succeed:
                $$&Delta; H = H_\text{after} - H_\text{before}$$ </li>
    <li> If the proposed change would <em>decrease</em> the global energy
        (i.e: &Delta;$H \lt 0$), we say it is energetically favourable
        and we let it proceed. This means we actually change the cell ID of the
        target pixel to that of the source pixel. If, however, the
        proposed change would <em>increase</em> the global energy
        (i.e: &Delta;$H \gt 0$), it is not favourable. We let it proceed only
        in some cases, with a probability of:
            $$P_\text{copy} = e^{- \Delta H/T}$$
        This ensures a copy attempt is less likely when it is more energetically
        favourable (&Delta;H more positive), but it becomes more likely when
        there is a higher <em>Temperature</em> T (Figure 3). </li>
    <li> Repeat the previous steps for a number of times equal to the number of
    pixels on the grid. This completes one <em>Monte Carlo Step (MCS)</em>,
    the time unit of the CPM. </li>
</ol>

<p>By following these steps, each time accepting mostly copy attempts that are
energetically favourable, the system minimizes its global energy.</p>

<div>
<br>
<table>
<tr>
    <td style="width:70%"> <img src="./manual/asset/deltaHfun.png" width="100%"> </td>
    <td style="width:30%"> <span style="font-size:90%"><b>Figure 3: Success
        chance P<sub>copy</sub> of a copy attempt as a function of the associated
        change &Delta;$H$.</b> <br> <i>If &Delta;$H \lt 0$,
     the copy attempt will always succeed. Otherwise, P<sub>copy</sub> drops
     exponentially with &Delta;$H$ - and does so more steeply for lower temperatures.
      </i></span> </td>
 </tr>
 </table>
<br>
</div></p><p>Notice that we here consider a <em>decrease</em> in energy to be a &quot;good thing&quot;: we 
call it energetically favourable. This may feel a little unintuitive, but is 
common practice among physicists and chemists. You can think of the internal 
energy of a system as the energy it <em>costs</em> to keep the system the way it is 
now (kind of like how an object you lift up gains <em>potential energy</em>; if 
it can decrease that energy by falling to the ground, it will). If we consider 
the energy $H$ as some kind of energy <em>cost</em>, it makes more sense that a 
negative &#x394;H is considered &quot;good&quot;.
</p><h2>The Hamiltonian</h2>
<p>Before, we have just assumed that we can calculate this energy $H$ 
somehow. We will here discuss how we come up with this magical number.
</p>
<p>The equation we use to calculate $H$ is called the Hamiltonian. This is no 
single Hamiltonian equation; it can contain many different components depending 
on what we are trying to model. The CPM is, therefore, not a single model but
rather a model <em>formalism</em> in which many different models can be constructed. 
This flexibility in designing the Hamiltonian is one of the nice properties of 
the CPM: we can model many types of processes by adding the right terms to the 
Hamiltonian equation; we just add up all these different energy terms or 
<em>constraints</em> to get the total $H$ of the system. This section will discuss 
some energy terms you may find interesting - but you&apos;ll find many more in 
literature.
</p><h3>Adhesion</h3>
<p>The most classical component of the Hamiltonian is the <em>adhesion</em> equation, 
which made up the entire Hamiltonian in the original Potts model of magnetic 
spins. Remember that in the Potts model, pixels were either &quot;spin up&quot; ($s = 0$) 
or &quot;spin down&quot; ($s = 1$) - similar to a grid with only background (cell ID = 0) 
and a single cell (cell ID = 1).
</p>
<p>In the original Potts model, adhesion energy was then given by a constant
energy $J$ summed up for every neighboring pixel pair $(i,j)$ with opposite spin
($s_i \neq s_j$) <a href="#graner-glazier">(1)</a>:
</p>


<p>
$$H_\text{Potts} = \sum_{\substack{\text{neighbors} \\ (i,j) | s_i \neq s_j } } J$$
</p></p><p>For their &quot;cellular&quot; Potts model of the differential adhesion hypothesis,
Graner and Glazier could not use this equation. After all, they wanted to model
a system with many cells (=cellIDs) instead of just one. In addition, these 
cells had to belong to two different <em>kinds</em> of cells - with a differential 
adhesion that depended on the kinds of cells interacting. In other words, they 
still needed to sum up a surface energy $J$ for all interactions between 
neighboring pixels $(i,j)$ with ID$_i$ $\neq$ ID$_j$, but the $amount$ of 
energy $J$ should now also depend on the cell kinds $(k_i, k_j)$ of the 
interacting cells (rather than being a constant number as before).
</p>
<p>This yielded the following equation (Figure 4) <a href="#graner-glazier">(1)</a>:
means that $J_{0,0}$ is never used, since we only sum up $J$ for neighboring
pixels with a <em>different</em> cell ID. If we then also have only one cell on the 
grid (only one non-zero cell ID), this means we also don&apos;t use $J_{1,1}$.
We end up with a single $J_{0,1} = J_{1,0} = J$ - the original Potts model 
equation (this is what we did to get the Ising model simulation at the top of
this page).
</p><h3>Volume</h3>
<p>A Hamiltonian with an adhesion term alone was not enough to obtain the 
Graner-Glazier model of cell sorting. Note that the system moves towards lower
energies by accepting copy attempts with negative &#x394;$H$. Since the 
adhesion term only puts an energy penalty on interactions between <em>different</em>
cells, there is a pretty simple solution to get a low energy: just remove
everything from the grid until every pixel has the same cell ID (for example,
the background ID = 0 - in fact, if you watch the simulation at the top of this
page for a while, this is probably what you will see). 
</p>
<p>To avoid this, Graner and Glazier added an additional term to their cellular
Potts model that constrained the cell&apos;s size, or <em>volume</em> (where &quot;volume&quot; is
just the number of pixels on the grid belonging to that cell). They used the
following equation <a href="#graner-glazier">(1)</a>:
</p>
<p>$$H_\text{volume} = \sum_{\text{cell IDs } n} \lambda_{\text{volume}, k_n}
    (V_n - V_{\text{target}, k_n})^2$$
</p>
<p>This equation essentially renders the cells elastic by giving each cell an 
energetic penalty if it deviates from some target volume - with the size of
that penalty increasing quadratically with the deviation size (Figure 5).
</p>
<div>
<br>
<table>
<tr>
    <td style="width:100%" align="center"> <img src="./manual/asset/cpm-explanation-04.svg" width="80%"> </td>
</tr>
<tr>
    <td style="width:100%"> <span style="font-size:90%"><b>Figure 5: The volume energy term.</b> <br>
    <i> For each cell $n$,
        we compare its current volume $V_n$ to its target volume $V_\text{target}$ -
        which is a model parameter that we have to specify for each cell kind on the
        grid. The squared difference between the actual and target cell volumes then
        appears as a penalty in the Hamiltonian, with a weight
        $\lambda_{\text{volume}, k_n}$ that also depends on the kind $k_n$ of cell $n$.
        This allows the cells to deviate <em>somewhat</em> from their target volume, but not
        too much: at large differences $(V_n - V_{\text{target}, k_n})$, the squared
        term will start to dominate the Hamiltonian, making these energetically
        unfavourable (note that we set $\lambda_{\text{volume}, k = 0} = 0$ to suppress
        this term for the "background" cell).
      </i></span> </td>
 </tr>
 </table>
<br>
</div></p><p>The volume term in combination with the adhesion term is sufficient to
reproduce cell sorting, as Graner and Glazier showed:
</p>
<div>
<iframe src="./manual/asset/Cellsorting.html" width="500px" height="320px"> </iframe>
</div></p><h3>Perimeter</h3><p>A frequently used variation of the <a href="#volume">volume constraint</a> is the 
perimeter constraint, which works in the same way but now makes the cell 
boundary elastic (rather than its area, Figure 6). The equation is analogous 
to the volume term:
</p>
<p>$$H_\text{perimeter} = \sum_{\text{cell IDs } n} \lambda_{\text{perimeter}, k_n}
    (P_n - P_{\text{target}, k_n})^2$$
</p>
<div>
<br>
<table>
<tr>
    <td style="width:100%" align="center"> <img src="./manual/asset/cpm-explanation-05.svg" width="80%"> </td>
</tr>
<tr>
    <td style="width:100%"> <span style="font-size:90%"><b>Figure 6: The perimeter energy term.</b> <br>
    <i> This term is very similar to the volume energy term. The perimeter of a cell
    is measured just like the adhesion, with each contact between a cell pixel and
    a neighbor pixel belonging to another cell contributing one unit to the perimeter.
    For each cell $n$,
        we then compare its current perimeter $P_n$ to its target perimeter $P_\text{target}$,
        again a model parameter that we have to specify for each cell kind on the
        grid. The squared difference between the actual and target cell perimeters then
        appears as a penalty in the Hamiltonian, with a weight
        $\lambda_{\text{perimeter}, k_n}$ that also depends on the kind $k_n$ of cell $n$.
        We again set $\lambda_{\text{perimeter}, k = 0} = 0$ to suppress
        this term for the "background" cell.
      </i></span> </td>
 </tr>
 </table>
<br>
</div></p><p>Note that just like the <a href="#adhesion">adhesion term</a>, we count the number of
contacts with neighbor pixels belonging to different cells (different cell ID).
However, whereas the adhesion scales linearly with the number of such contacts
(awarding some constant energy $J$ per contact), we now look at the <em>deviation</em>
from a target number of contacts (perimeter) - and this appears in the
Hamiltonian as a squared (rather than linear) term. By combining an adhesion 
term with a perimeter term (and a volume term), we get a cell with a &quot;ruffling 
membrane&quot; that still sticks together:
</p>
<div>
<iframe src="./manual/asset/perimeterExample.html" width="500px" height="260px"> </iframe>
</div></p><p>Unlike with the adhesion term, removing all cells
from the grid is no longer a simple solution to decrease the global energy.
While the solution with no cells may still have the lowest energy (the term
sums over cells, so without cells there is no penalty), the system has no way
to achieve that state: to remove all pixels belonging to a cell, that cell first
has to <em>decrease</em> its perimeter $P \rightarrow 0$. Any copy attempt that tries
to remove a pixel from a cell with a perimeter that is already too small will 
have a very large positive $\Delta H_\text{perimeter}$, and is therefore 
unlikely to succeed.
</p><h3>Cell motion: extrinsic</h3>
<p>While the cells we have seen so far have <em>dynamic</em> membranes and float around
to some extent, we cannot yet speak of active motion. Several other extensions 
to the Hamiltonian have been developed to obtain cell migration in the CPM.
</p>
<p>The easiest way to make cells move is by letting them respond to some external
attracting force, which favours copy attempts in a given direction. 
</p>
<p>AttractionPointConstraint, PreferredDirectionConstraint, ChemotaxisConstraint
</p><h3>Cell motion: intrinsic</h3><p>ActivityConstraint, PersistenceConstraint</p><h3>Enforcing cell connectivity</h3><h2>References</h2><p>[1] <a id="graner-glazier"></a> Graner &amp; Glazier (1992). 
    <a href="https://www.if.ufrgs.br/~leon/cursopg/mod_min/Articles/PRL_69-13-2013.pdf">
        Simulation of biological cell sorting using a two-dimensional extended Potts model. 
    </a>
</p>
<p>[2] <a id="basic-potts"></a> Wikipedia. 
    <a href="https://en.wikipedia.org/wiki/Potts_model">
        The Potts model.
    </a>
</p>
<p>[3] <a id="cpm-history"></a> Glazier, Balter, Poplawski (2007).
    <a href="https://link.springer.com/chapter/10.1007/978-3-7643-8123-3_4">
        Magnetization to Morphogenesis: a brief history of the 
        Glazier-Graner-Hogeweg model.
    </a>
</p></div>
        <a data-ice="link" href="manual/introCPM.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Getting started</h1><h2>Set up CPMjs in 3 easy steps</h2><h3>Step 1: download the repository.</h3>
<p><strong>Via the Github website</strong>
</p><p>Visit the <a href="https://github.com/jtextor/cpmjs">Github repository</a> and click on the
green &quot;clone or download&quot; button, then select &quot;Download ZIP&quot;:
</p>
<p><img class="screen-shot" src="./manual/asset/github-repo2.png" width="80%">
</p><p>Save the zipped folder somewhere on your computer and unzip.</p><p><strong>Via the command line</strong></p><p>Alternatively, in the console, go to the folder where you want to save CPMjs,
and clone the repository:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">cd folder/to/save-into/
git clone https://github.com/jtextor/cpmjs.git</code>
</code></pre><h3>Step 2: install node dependencies.</h3>
<p>Most users will run CPMjs in browser simulations only and will not need to
extend the software with custom modules. If that&apos;s you, you can skip this step.
But if you plan to use CPMjs from the command line using node, or if you plan
to write your own modules (such as hamiltonian terms), you will need to install
some node dependencies.
</p>
<p>To do this, go to the <code>cpmjs/</code> folder from the command line and install the
required packages automatically using <code>npm</code>:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">cd folder/containing/cpmjs
npm install</code>
</code></pre>
<p>If you do not have <code>nodejs</code> and its package manager <code>npm</code>, see
<a href="https://nodejs.org/en/download/">this page</a> to install them first.
</p><h3>Step 3: link the build in your code.</h3>
<p>You can now use CPMjs! See this <a href="./manual/quickstart.html">tutorial</a> to build your first
simulation, or start from one of the simulations in the <code>cpmjs/examples/</code>
folder. In these examples, you will see that the package can be loaded as
follows:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;script src=&quot;path/to/cpmjs/build/cpm.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>for html, and
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let CPM = require(&quot;path/to/cpmjs/build/cpm-cjs.js&quot;)</code>
</code></pre>
<p>for node scripts.
</p><p>When you include these lines in your own scripts, just make sure they contain
the correct path from your simulation file to the <code>cpmjs/build/</code> folder.
</p><h3>Additional notes</h3>
<p>If you wish to build simulations in a different directory than the <code>cpmjs</code>
folder, it may be convenient to create a symbolic link to the <code>build</code> folder
there:
</p><pre><code><code class="source-code prettyprint">cd path/to/my/simulations
ln -s path/to/cpmjs/build build</code>
</code></pre>
<p>You can then access the code using:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;script src=&quot;path/to/my/simulations/build/cpm.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>or
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let CPM = require(&quot;path/to/my/simulations/build/cpm-cjs.js&quot;)</code>
</code></pre>
<p>Finally, if you want to run CPMjs simulations with nodejs from this folder,
you will need to create a link to the installed <code>node_modules</code> from step 2:
</p><pre><code class="lang-console"><code class="source-code prettyprint">cd path/to/my/simulations
ln -s path/to/cpmjs/node_modules node_modules</code>
</code></pre></div>
        <a data-ice="link" href="manual/installation.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Your First Simulation</h1>
<p>This tutorial will show you how to build a simple simulation in the web browser
or in a nodejs script. Choose either
<a href="#set-up-a-simulation-in-the-web-browser">Set up a simulation in the web browser</a>
or <a href="#set-up-a-simulation-in-nodejs">Set up a simulation in nodejs</a> to get the
required template code, and then see
<a href="#writing-your-simulation">Writing your simulation</a> to start using CPMjs in the
environment of your choice.
</p>
<p>The simulation we will build is a simple CPM cell:
</p><p><div>
&lt;iframe src=&quot;./manual/asset/SingleCell.html&quot; width=&quot;350px&quot; height=&quot;400px&quot;&gt; &lt;/iframe&gt;
</div>


</p><h2>Set up a simulation in the web browser</h2>
<p>One way to use CPMjs is to build a simulation in HTML, to open directly in
your favourite web browser (as long as that favourite web browser is not
Internet Explorer). The advantage of this method is that it allows you to
visualize the simulation immediately, and that you can easily explore the
effect of changing parameters in this manner. However, if you wish to run a
simulation and store output to your computer, a simulation using nodejs may be
more appropriate &#x2013; see <a href="#set-up-a-simulation-in-nodejs">Set up a simulation in nodejs</a>
for details.
</p><h3>An HTML template page</h3>
<p>Unfortunately, writing an HTML page requires quite some boilerplate code. You
can mostly just copy-paste this for every simulation you build. For now,
we will just copy-paste the following template so you can continue with
<a href="#writing-your-simulation">building your simulation</a>. If you are unfamiliar with
HTML, you may want to check out <a href="./manual/htmlTemplate.html">this tutorial</a> later --
it will guide you through the template 
step by step so you know which parts you may have to adapt. 
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;!-- Page setup and title --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;
charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt; 
body{
    font-family: &quot;HelveticaNeue-Light&quot;, sans-serif; padding : 15px;
}
&lt;/style&gt;

&lt;!-- Sourcing the cpm build --&gt;
&lt;script src=&quot;../../build/cpm.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;

            // Simulation code here.


&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;initialize()&quot;&gt;
&lt;h1&gt;Your Page Title&lt;/h1&gt;
&lt;p&gt;
Description of your page.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</code></pre>
<p>Copy the above code into a file called <code>MyFirstSimulation.html</code>, which you can
save in the <code>cpmjs/examples/html/</code> folder for now. 
</p><blockquote>

<p>! <em>Important</em>: If you wish to save the file elsewhere, please read 
<a href="./manual/installation.html#additional-notes">these instructions</a> 
first, and ensure that you include the correct path to the cpm build in
the part <code>&lt;script src=&quot;../../build/cpm.js&quot;&gt;&lt;/script&gt;</code>.
</p>
</blockquote>
<p>You can now proceed with
 <a href="#writing-your-simulation">adding your simulation</a> to this file.
</p><h2>Set up a simulation in nodejs</h2>
<p>Another way to use CPMjs &#x2013; besides using HTML &#x2013; is to use nodejs from the 
console. This method of running CPMjs allows you to print statistics to the 
console and store them in external files, as well as to save images of the 
simulation to create a movie later. To set up a more interactive version 
of your simulation with a live animation, an HTML version may be more 
appropriate &#x2013; see 
<a href="#set-up-a-simulation-in-the-web-browser">Set up a simulation in the web browser</a>
</p>
<p>In contrast to a browser simulation, a node simulation requires almost no 
boilerplate code. 
</p>
<p>To set up your first node simulation, just create a file <code>MyFirstSimulation.js</code>
in the folder <code>cpmjs/examples/node/</code> 
(or see <a href="./manual/installation.html#additional-notes">these instructions</a> to create it 
elsewhere). Then add the following line of code to the (still empty) script to
source the package:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">/* Source the CPM module (cpm-cjs version because this is a node script).*/
let CPM = require(&quot;../../build/cpm-cjs.js&quot;)</code>
</code></pre>
<p>Make sure that the path supplied to <code>require()</code> is the correct path from the
location of <code>MyFirstSimulation.js</code> to <code>cpmjs/build/cpm-cjs.js</code>.
</p>
<p>You can now proceed with <a href="#writing-your-simulation">adding your simulation</a>.
</p><h2>Writing your simulation</h2><p>We are now ready to add some simulation code. The following code goes either
in between the <code>&lt;script&gt;&lt;/script&gt;</code> tags of your HTML page (see the comment
<code>// Simulation code here</code>), or at the bottom of your node script.
</p>
<p>The easiest way to build a simulation in CPMjs is to use the 
<a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a>.
This class provides some default methods for running the simulation and 
producing outputs, so we won&apos;t have to worry about this yet. 
</p><h3>Step 1 : Configure the CPM &amp; Simulation</h3>
<p>The first thing we need to do is supply a <code>config</code> object with all the required
parameters and settings for the simulation. A configuration object for a simulation 
should look something like this:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {

    ndim : 2,
    field_size : [50,50],
    conf : {

    },
    simsettings : {

    }
}</code>
</code></pre>
<p>Here, <code>ndim</code> is the number of dimensions of the grid, <code>field_size</code> is the 
number of pixels in each dimension (in this case: 50 x 50 pixels), <code>conf</code> is 
the configuration object parsed to the 
<a href="./manual/../class/src/models/CPM.js~CPM.html">CPM class</a>, and <code>simsettings</code>
contains configuration options used directly by the simulation class.
</p>
<p>First, we configure the CPM by setting values in the <code>conf</code> object:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">conf : {
        T : 20,                        // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],            // VolumeConstraint importance per cellkind
        V : [0,500]                    // Target volume of each cellkind

    }</code>
</code></pre>
<p>The <code>T</code> parameter is the CPM temperature, which determines how strongly the 
model &quot;listens&quot; to the energy constraints given in the CPM. We then add 
an <a href="./manual/../class/src/hamiltonian/Adhesion.js~Adhesion.html">adhesion</a> and 
<a href="./manual/../class/src/hamiltonian/VolumeConstraint.js~VolumeConstraint.html">volume constraint</a> 
by supplying their parameters. In this case, we will have only one type of cell
and the background, so parameters are arrays of length 2 (or a 2 by 2 matrix 
for the adhesion parameters).
</p>
<p>Finally, we need to supply some settings for the simulation class itself in
<code>simsettings</code>:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">simsettings : {
    NRCELLS : [1],
    RUNTIME : 500,
    CANVASCOLOR : &quot;eaecef&quot;,
    zoom : 4
}</code>
</code></pre>
<p>This ensures that one cell is seeded on the grid before the simulation, the
simulation runs for 500 MCS (in node; in the browser it will just keep running),
the background of the grid is colored gray, and the grid is drawn at 4x zoom.
</p>
<p>The full <code>config</code> object becomes:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {

    // Grid settings
    ndim : 2,
    field_size : [100,100],

    // CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },

    // Simulation setup and configuration
    simsettings : {
        // Cells on the grid
        NRCELLS : [1],                    // Number of cells to seed for all
                                        // non-background cellkinds.

        RUNTIME : 500,                  // Only used in node

        CANVASCOLOR : &quot;eaecef&quot;,
        zoom : 4                        // zoom in on canvas with this factor.
    }
}</code>
</code></pre><h3>Step 2: Create a simulation object</h3>
<p>Once we have the configuration object, we can use it to construct a simulation.
</p><h4>In nodejs</h4><p>In nodejs, simply construct the simulation as follows:</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let sim = new CPM.Simulation( config )</code>
</code></pre><h4>In HTML</h4>
<p>If you are writing an HTML page, you have to define an <code>initialize()</code> function -
as this is the function that will be run when the page is loaded (see 
<a href="./manual/htmlTemplate.html#step-4-write-the-body">this section</a>):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let sim
function initialize(){
    sim = new CPM.Simulation( config )
}</code>
</code></pre><h3>Step 3 : Tell the simulation to run</h3>
<p>We are now almost ready; the only thing still missing is a command in the script
that tells the simulation to start running. This works slightly differently in
the browser- and nodejs versions.
</p><h4>In nodejs</h4>
<p>In nodejs, getting the simulation to run is easy: just call the <code>run()</code> method
of the simulation class after creating the simulation object. We get:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    ...
}
let sim = new CPM.Simulation( config )
sim.run()</code>
</code></pre>
<p>You are now ready to run your simulation. From your console, run the script with
node:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">node path/to/MyFirstSimulation.js</code>
</code></pre><h4>In HTML</h4>
<p>In HTML, we create a function that runs a single step, and then make sure that
this function is called from the <code>initialize()</code> function:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    ...
}
let sim
function initialize(){
    sim = new CPM.Simulation( config )
    step()
}
function step(){
    sim.step()
    requestAnimationFrame( step )
}</code>
</code></pre>
<p>To see your simulation, open your file MyFirstSimulation.html in the web 
browser (any except Internet Explorer; but we recommend Chrome because it is fast).
</p></div>
        <a data-ice="link" href="manual/quickstart.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>An HTML template page</h1>
<p>This tutorial will take you through the HTML simulation template 
step by step so you know which parts you may have to adapt when 
you are building your own simulations.
</p><h3>An HTML template</h3>
<p>We will build the following template:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;!-- Page setup and title --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;
charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt; 
body{
    font-family: &quot;HelveticaNeue-Light&quot;, sans-serif; padding : 15px;
}
&lt;/style&gt;

&lt;!-- Sourcing the cpm build --&gt;
&lt;script src=&quot;../../build/cpm.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;

            // Simulation code here.


&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;initialize()&quot;&gt;
&lt;h1&gt;Your Page Title&lt;/h1&gt;
&lt;p&gt;
Description of your page.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</code></pre>
<p>We will now go through this step by step.
</p><h3>Step 1 : Create a basic HTML page</h3><p>A very simple html page looks like this:</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; &lt;/head&gt;
&lt;body&gt; &lt;/body&gt;
&lt;/html&gt;</code>
</code></pre>
<p>The <code>&lt;html&gt;</code> tag shows where the page starts, and <code>&lt;/html&gt;</code> shows where it ends.
The page consists of a <em>header</em>, which starts at <code>&lt;head&gt;</code> and ends at <code>&lt;/head&gt;</code>,
and a <em>body</em>, starting at <code>&lt;body&gt;</code> and ending at <code>&lt;/body&gt;</code>. (In general,
anything you place in your HTML file starts with <code>&lt;something&gt;</code> and ends with
<code>&lt;/something&gt;</code>).
</p><h3>Step 2 : Configure the header</h3>
<p>The header of the HTML page is the place that contains some meta-information
about that page, and will also contain the simulation code.
</p>
<p>First, we will expand the header code above (between the <code>&lt;head&gt;&lt;/head&gt;</code> tags):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;/head&gt;</code>
</code></pre>
<p>The additional code in the first line just includes some document settings into 
the header that you will rarely need to change. The only thing you may want to 
change is the second line, where you set the title that will be displayed
in the open tab in your web browser when you open the page.
</p><h3>Step 3 : Add JavaScript</h3>
<p>We will now add some JavaScript code to the header part of the page (again,
between the <code>&lt;head&gt;&lt;/head&gt;</code> tags):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;script src=&quot;path/to/cpmjs/build/cpm.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;
// Simulation code will go here:

&lt;/script&gt;
&lt;/head&gt;</code>
</code></pre>
<p>The first script just loads the CPMjs package for HTML, which is stored in
<code>cpmjs/build/cpm.js</code>. Please ensure that the path supplied here is the correct
path from the folder where you stored <code>MyFirstSimulation.html</code> to the file
<code>cpmjs/build/cpm.js</code>. If you have stored your simulation in <code>cpmjs/examples/html</code>,
you can use the path <code>../../build/cpm.js</code>
</p>
<p>The second script is where your actual simulation code
will go when you are <a href="./manual/quickstart.html#writing-your-simulation">Writing your simulation</a>.
For now, we&apos;ll leave it empty.
</p><h3>Step 4: Write the body</h3>
<p>Finally, we make some changes to the body of the page (between the <code>&lt;body&gt;&lt;/body&gt;</code> tags):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;body onload=&quot;initialize()&quot;&gt;
&lt;h1&gt;Your Page Title&lt;/h1&gt;
&lt;p&gt;
Description of your page.
&lt;/p&gt;
&lt;/body&gt;</code>
</code></pre>
<p>In the first line, we tell the HTML page to run the JavaScript function 
<code>intitialize()</code>, which we will define later in 
<a href="./manual/quickstart.html#writing-your-simulation">Writing your simulation</a> (between the 
<code>&lt;script&gt;&lt;/script&gt;</code> tags of the page header we just set up).
</p>
<p>The rest of the code just adds a title and a description to the web page.
The simulation will then be placed below (as in the example shown
at the top of this page).
</p><h3>Step 5 (optional): Add CSS</h3>
<p>The code we have now added is sufficient to make the page work once we have
<a href="./manual/quickstart.html#writing-your-simulation">added a simulation</a>, but to make it look better we
may want to add some CSS styling code to the header of the page. The header now
becomes:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">
&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;

&lt;style type=&quot;text/css&quot;&gt; 
body{
font-family: &quot;HelveticaNeue-Light&quot;, sans-serif; padding : 15px;
}
&lt;/style&gt;

&lt;script src=&quot;path/to/cpmjs/build/cpm.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;
// Simulation code will go here:

&lt;/script&gt;
&lt;/head&gt;</code>
</code></pre>
<p>To see the final result, have a look again at the complete
 <a href="#an-html-template">template</a>. You can now proceed with
 <a href="./manual/quickstart.html#writing-your-simulation">adding your simulation</a> to this file.
</p></div>
        <a data-ice="link" href="manual/htmlTemplate.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Configuring Simulations (1)</h1>
<p>Once you have written a <a href="./manual/quickstart.html">fist simulation</a>, you can make
it more complex by adding different CPM energy constraints, 
or you can increase the number of cells in your simulation and examine 
interactions between different cell types. 
</p>
<p>The <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a>
allows you to make many of those changes by simply modifying the its
<a href="./manual/quickstart.html">configation object</a>, which will be the topic of this tutorial. 
The next tutorial will show you how you can make even more advanced simulations 
by writing custom functions - but for now we will focus on changes you can make
through configuration only. 
</p>
<p>We will start from this very simple simulation from the 
<a href="./manual/quickstart.html">previous tutorial</a>:
</p>
<p><div>
&lt;iframe src=&quot;./manual/asset/SingleCell.html&quot; width=&quot;350px&quot; height=&quot;400px&quot;&gt; &lt;/iframe&gt;
</div>


</p>
<p>This tutorial assumes you have completed the previous tutorial, and we will 
examine the <code>config</code> object of the simulation you generated there in more detail:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {

    // Grid settings
    field_size : [100,100],

    // CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },

    // Simulation setup and configuration
    simsettings : {
        // Cells on the grid
        NRCELLS : [1],                    // Number of cells to seed for all
                                        // non-background cellkinds.

        RUNTIME : 500,                  // Only used in node

        CANVASCOLOR : &quot;eaecef&quot;,
        zoom : 4                        // zoom in on canvas with this factor.
    }
}</code>
</code></pre>
<p>We will now see how changes to this object can alter the simulation. 
</p><h2>Configuring the CPM itself</h2><p>First, let&apos;s see how we can control the <a href="./manual/../class/src/models/CPM.js~CPM.html">CPM model class</a> itself. For this lesson,
we recommend starting from the HTML version of the simulation in the 
<a href="./manual/quickstart.html">previous tutorial</a>. This HTML version will allow you to
see the effect of your changes more quickly than running a node script would.
</p><h3>Changing CPM constraints</h3>
<p>As we&apos;ve seen before, the <code>config</code> object has three parts: the <code>field_size</code>, 
the <code>conf</code>, and the <code>simsettings</code>. We will now look at the <code>conf</code> part, which
controls the CPM model itself.
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">    // CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },</code>
</code></pre>
<p>Remember that CPMs work by defining a &quot;global energy&quot; in the form of an equation
called the <em>Hamiltonian</em>. Whether or not a pixel changes in the CPM then depends
on how this would change the global energy: if the pixel change <em>decreases</em> the
global energy (=energetically favourable), the pixel change will happen. If it
would <em>increase</em> the global energy, 
</p><h3>Configuring the grid</h3><h4><strong>Field size</strong></h4>
<p>Open your file <code>MyFirstSimulation.html</code> from the previous tutorial in the web
browser. You should see a black cell floating inside a square gray area, which
is the field or &quot;grid&quot; the simulation runs in. 
</p>
<p>The size of this grid is controlled by <code>field_size</code> in the <code>config</code> object.
The entry 
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">    // Grid settings
    field_size : [100,100],</code>
</code></pre>
<p>ensures that the simulation is performed on a 100 x 100 pixel (2D) grid. We
can change the size of this grid by changing the numbers <code>x</code> and <code>y</code> between
the square brackets: <code>[x,y]</code>, where <code>x</code> controls the grid&apos;s width and 
<code>y</code> controls its height. For example, changing this setting to:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">    // Grid settings
    field_size : [150,100],</code>
</code></pre>
<p>makes the grid slightly broader, but equally high as before.
</p><p><strong>Exercise</strong> : </p><p><em>How would you make a grid with a width of 100 pixels and a
height of 200 pixels? Open your file</em> <code>MyFirstSimulation.html</code> <em>in your 
favourite text editor, change the</em> <code>field_size</code> <em>in the appropriate manner, and
save the file. Now open</em> <code>MyFirstSimulation.html</code> <em>in your web browser (or just
refresh the page if you had already done so). Did it work?</em>
</p><h4><strong>Grid boundaries</strong></h4><h3>Setting a seed</h3><h2>Configuring the Simulation object</h2><h3>Controlling the simulation</h3><h3>Controlling the visualization</h3><h3>Controlling outputs</h3></div>
        <a data-ice="link" href="manual/simulationConfig.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
